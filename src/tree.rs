//! Exports a persistent, serializing/deserializing ordered tree.

use crate::{
    buffer::{self, Buffer},
    decode,
    error::Error,
};
use std::{fmt, future::Future, marker::PhantomData};
use tokio::task;

/// An ID generated by the tree.
pub type Id = u64;

/// A persistent key-value structure.
pub struct Tree<K, V>
where
    for<'de> K: serde::Serialize + serde::Deserialize<'de>,
    for<'de> V: serde::Serialize + serde::Deserialize<'de>,
{
    storage: sled::Tree,
    _marker: PhantomData<(K, V)>,
}

impl<K, V> Tree<K, V>
where
    for<'de> K: serde::Serialize + serde::Deserialize<'de>,
    for<'de> V: serde::Serialize + serde::Deserialize<'de>,
{
    /// Opens this tree from a database.
    pub async fn open<T>(db: &sled::Db, name: T) -> Result<Self, Error>
    where
        T: AsRef<[u8]>,
    {
        let storage = task::block_in_place(|| db.open_tree(name))?;
        Ok(Self { storage, _marker: PhantomData })
    }

    async fn get_raw(
        &self,
        key: &K,
        key_buf: &mut Buffer,
    ) -> Result<Option<V>, Error> {
        let encoded_key = key_buf.encode(key)?;
        let maybe = task::block_in_place(|| self.storage.get(&encoded_key))?;
        match maybe {
            Some(encoded_value) => {
                let val = decode(&encoded_value)?;
                Ok(Some(val))
            },
            None => Ok(None),
        }
    }

    /// Gets the value associated with the given `key`, returning `None` if key
    /// is not found. Serializes key using a buffer from a thread-local buffer
    /// pool.
    pub async fn get(&self, key: &K) -> Result<Option<V>, Error> {
        self.get_with(key, buffer::DefaultPool).await
    }

    /// Gets the value associated with the given `key`, returning `None` if key
    /// is not found. Uses the given allocation strategy for making buffers.
    pub async fn get_with<A>(
        &self,
        key: &K,
        mut allocation: A,
    ) -> Result<Option<V>, Error>
    where
        A: buffer::Allocation,
    {
        let mut key_buf = allocation.make();
        let result = self.get_raw(key, &mut key_buf).await;
        allocation.save(key_buf);
        result
    }

    async fn insert_raw(
        &self,
        key: &K,
        val: &V,
        key_buf: &mut Buffer,
        val_buf: &mut Buffer,
    ) -> Result<Option<V>, Error> {
        let encoded_key = key_buf.encode(key)?;
        let encoded_value = val_buf.encode(val)?;
        let encoded = task::block_in_place(|| {
            self.storage.insert(&encoded_key, encoded_value)
        })?;
        match encoded {
            Some(encoded_val) => Ok(Some(decode(&encoded_val)?)),
            None => Ok(None),
        }
    }

    /// Inserts key and value returning `None` if key is new, `Some(old_value)`
    /// if the key already exists (and replacing its data). Serializes key and
    /// value using a buffer from a thread-local buffer pool.
    pub async fn insert(&self, key: &K, val: &V) -> Result<Option<V>, Error> {
        self.insert_with(key, val, buffer::DefaultPool).await
    }

    /// Inserts key and value returning `None` if key is new, `Some(old_value)`
    /// if the key already exists (and replacing its data). Uses the given
    /// allocation strategy for making buffers.
    pub async fn insert_with<A>(
        &self,
        key: &K,
        val: &V,
        mut allocation: A,
    ) -> Result<Option<V>, Error>
    where
        A: buffer::Allocation,
    {
        let mut key_buf = allocation.make();
        let mut val_buf = allocation.make();
        let result =
            self.insert_raw(key, val, &mut key_buf, &mut val_buf).await;
        allocation.save(key_buf);
        allocation.save(val_buf);
        result
    }

    async fn contains_key_raw(
        &self,
        key: &K,
        key_buf: &mut Buffer,
    ) -> Result<bool, Error> {
        let encoded_key = key_buf.encode(key)?;
        let result =
            task::block_in_place(|| self.storage.contains_key(&encoded_key))?;
        Ok(result)
    }

    /// Tests if the given key exist. Serializes key using a buffer from a
    /// thread-local buffer pool.
    pub async fn contains_key(&self, key: &K) -> Result<bool, Error> {
        self.contains_key_with(key, buffer::DefaultPool).await
    }

    /// Tests if the given key exist. Uses the given allocation strategy for
    /// making buffers.
    pub async fn contains_key_with<A>(
        &self,
        key: &K,
        mut allocation: A,
    ) -> Result<bool, Error>
    where
        A: buffer::Allocation,
    {
        let mut key_buf = allocation.make();
        let result = self.contains_key_raw(key, &mut key_buf).await;
        allocation.save(key_buf);
        result
    }

    async fn remove_raw(
        &self,
        key: &K,
        key_buf: &mut Buffer,
    ) -> Result<Option<V>, Error> {
        let encoded_key = key_buf.encode(key)?;
        match task::block_in_place(|| self.storage.remove(&encoded_key))? {
            Some(encoded_val) => Ok(Some(decode(&encoded_val)?)),
            None => Ok(None),
        }
    }

    /// Removes the value associated with the given `key`, returning `None` if
    /// key is not found. Serializes key using a buffer from a thread-local
    /// buffer pool.
    pub async fn remove(&self, key: &K) -> Result<Option<V>, Error> {
        self.remove_with(key, buffer::DefaultPool).await
    }

    /// Removes the value associated with the given `key`, returning `None` if
    /// key is not found. Uses the given allocation strategy for making buffers.
    pub async fn remove_with<A>(
        &self,
        key: &K,
        mut allocation: A,
    ) -> Result<Option<V>, Error>
    where
        A: buffer::Allocation,
    {
        let mut key_buf = allocation.make();
        let result = self.remove_raw(key, &mut key_buf).await;
        allocation.save(key_buf);
        result
    }

    async fn generate_id_raw<E, FK, FV, AK, AV>(
        &self,
        db: &sled::Db,
        key_buf: &mut Buffer,
        val_buf: &mut Buffer,
        mut make_id: FK,
        make_data: FV,
    ) -> Result<K, E>
    where
        E: From<Error>,
        FK: FnMut(Id) -> AK,
        FV: FnOnce(&K) -> AV,
        AK: Future<Output = Result<K, E>>,
        AV: Future<Output = Result<V, E>>,
    {
        loop {
            let gen_result = task::block_in_place(|| db.generate_id());
            let generated = gen_result.map_err(Error::from)?;
            let id = make_id(generated).await?;

            let contains = self.contains_key_raw(&id, key_buf).await?;

            if !contains {
                let data = make_data(&id).await?;
                self.insert_raw(&id, &data, key_buf, val_buf).await?;
                break Ok(id);
            }

            task::yield_now().await;
        }
    }

    /// Tries to generate a new ID as a key of an entry, and when successful,
    /// inserts the key with a value. First of all, it generates an integer, and
    /// then it uses the given future-function `make_id` to produce a key. When
    /// an actual new key is found, it uses another future-function `make_data`
    /// to produce a value associated with the key. With a key-value pair, it
    /// inserts them in the tree. Serializes key and value using a buffer from a
    /// thread-local buffer pool.
    pub async fn generate_id<E, FK, FV, AK, AV>(
        &self,
        db: &sled::Db,
        make_id: FK,
        make_data: FV,
    ) -> Result<K, E>
    where
        E: From<Error>,
        FK: FnMut(Id) -> AK,
        FV: FnOnce(&K) -> AV,
        AK: Future<Output = Result<K, E>>,
        AV: Future<Output = Result<V, E>>,
    {
        self.generate_id_with(db, buffer::DefaultPool, make_id, make_data).await
    }

    /// Tries to generate a new ID as a key of an entry, and when successful,
    /// inserts the key with a value. First of all, it generates an integer, and
    /// then it uses the given future-function `make_id` to produce a key. When
    /// an actual new key is found, it uses another future-function `make_data`
    /// to produce a value associated with the key. With a key-value pair, it
    /// inserts them in the tree. Uses the given allocation strategy for making
    /// buffers.
    pub async fn generate_id_with<A, E, FK, FV, AK, AV>(
        &self,
        db: &sled::Db,
        mut allocation: A,
        make_id: FK,
        make_data: FV,
    ) -> Result<K, E>
    where
        A: buffer::Allocation,
        E: From<Error>,
        FK: FnMut(Id) -> AK,
        FV: FnOnce(&K) -> AV,
        AK: Future<Output = Result<K, E>>,
        AV: Future<Output = Result<V, E>>,
    {
        let mut key_buf = allocation.make();
        let mut val_buf = allocation.make();
        let result = self
            .generate_id_raw(db, &mut key_buf, &mut val_buf, make_id, make_data)
            .await;
        allocation.save(key_buf);
        allocation.save(val_buf);
        result
    }
}

impl<K, V> Clone for Tree<K, V>
where
    for<'de> K: serde::Serialize + serde::Deserialize<'de>,
    for<'de> V: serde::Serialize + serde::Deserialize<'de>,
{
    fn clone(&self) -> Self {
        Self { _marker: self._marker, storage: self.storage.clone() }
    }
}

impl<K, V> fmt::Debug for Tree<K, V>
where
    for<'de> K: serde::Serialize + serde::Deserialize<'de>,
    for<'de> V: serde::Serialize + serde::Deserialize<'de>,
{
    fn fmt(&self, fmtr: &mut fmt::Formatter) -> fmt::Result {
        fmtr.debug_struct("Tree").field("storage", &self.storage).finish()
    }
}
