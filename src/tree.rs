//! Exports a persistent, serializing/deserializing ordered tree.

use crate::{decode, encode_into, error::Error};
use std::{fmt, future::Future, marker::PhantomData};
use tokio::task;

/// Buffer for more efficient allocation on key-value serialization.
#[derive(Debug, Default)]
pub struct EncodeBuffer {
    key: Vec<u8>,
    value: Vec<u8>,
}

impl EncodeBuffer {
    /// Frees the key buffer.
    pub fn free_key(&mut self) {
        self.key = Vec::new();
    }

    /// Frees the value buffer.
    pub fn free_value(&mut self) {
        self.value = Vec::new();
    }

    /// Encodes the given key using serde serialization.
    pub fn encode_key<K>(&mut self, key: K) -> Result<&[u8], Error>
    where
        K: serde::Serialize,
    {
        self.key.clear();
        encode_into(key, &mut self.key)?;
        Ok(&self.key)
    }

    /// Encodes the given value using serde serialization.
    pub fn encode_value<V>(&mut self, value: V) -> Result<&[u8], Error>
    where
        V: serde::Serialize,
    {
        self.value.clear();
        encode_into(value, &mut self.value)?;
        Ok(&self.value)
    }

    /// Encodes the given pair using serde serialization.
    pub fn encode<K, V>(
        &mut self,
        key: K,
        value: V,
    ) -> Result<(&[u8], &[u8]), Error>
    where
        K: serde::Serialize,
        V: serde::Serialize,
    {
        self.encode_key(key)?;
        self.encode_value(value)?;
        Ok((&self.key, &self.value))
    }

    /// Returns the last encoded key. Empty slice if no encoded key, but this
    /// overlaps with keys that serialize into an empty slice.
    pub fn last_key(&self) -> &[u8] {
        &self.key
    }

    /// Returns the last encoded value. Empty slice if no encoded value, but
    /// this overlaps with values that serialize into an empty slice.
    pub fn last_value(&self) -> &[u8] {
        &self.value
    }
}

/// An ID generated by the tree.
pub type Id = u64;

/// A persistent key-value structure.
pub struct Tree<K, V>
where
    for<'de> K: serde::Serialize + serde::Deserialize<'de>,
    for<'de> V: serde::Serialize + serde::Deserialize<'de>,
{
    storage: sled::Tree,
    _marker: PhantomData<(K, V)>,
}

impl<K, V> Tree<K, V>
where
    for<'de> K: serde::Serialize + serde::Deserialize<'de>,
    for<'de> V: serde::Serialize + serde::Deserialize<'de>,
{
    /// Opens this tree from a database.
    pub async fn open<T>(db: &sled::Db, name: T) -> Result<Self, Error>
    where
        T: AsRef<[u8]>,
    {
        let storage = task::block_in_place(|| db.open_tree(name))?;
        Ok(Self { storage, _marker: PhantomData })
    }

    /// Gets a value associated with a given key using the given allocated
    /// buffer to serialize and dserialize key and value.
    pub async fn get_with_buf(
        &self,
        key: &K,
        buffer: &mut EncodeBuffer,
    ) -> Result<Option<V>, Error> {
        let encoded_key = buffer.encode_key(key)?;
        let maybe = task::block_in_place(|| self.storage.get(&encoded_key))?;
        match maybe {
            Some(encoded_value) => {
                let val = decode(&encoded_value)?;
                Ok(Some(val))
            },
            None => Ok(None),
        }
    }

    /// Gets a value associated with a given key creating a one-time use buffer.
    pub async fn get(&self, key: &K) -> Result<Option<V>, Error> {
        self.get_with_buf(key, &mut EncodeBuffer::default()).await
    }

    /// Inserts a value associated with a given key using the given allocated
    /// buffer to serialize and dserialize key and value.
    pub async fn insert_with_buf(
        &self,
        key: &K,
        val: &V,
        buffer: &mut EncodeBuffer,
    ) -> Result<(), Error> {
        let (encoded_key, encoded_value) = buffer.encode(key, val)?;
        task::block_in_place(|| {
            self.storage.insert(&encoded_key, encoded_value)
        })?;
        Ok(())
    }

    /// Inserts a value associated with a given key creating a one-time use
    /// buffer.
    pub async fn insert(&self, key: &K, val: &V) -> Result<(), Error> {
        self.insert_with_buf(key, val, &mut EncodeBuffer::default()).await
    }

    /// Returns whether the given key is present in this tree using the given
    /// allocated buffer to serialize and dserialize key and value.
    pub async fn contains_key_with_buf(
        &self,
        key: &K,
        buffer: &mut EncodeBuffer,
    ) -> Result<bool, Error> {
        let encoded_key = buffer.encode_key(key)?;
        let result =
            task::block_in_place(|| self.storage.contains_key(&encoded_key))?;
        Ok(result)
    }

    /// Returns whether the given key is present in this tree creating a
    /// one-time use buffer.
    pub async fn contains_key(&self, key: &K) -> Result<bool, Error> {
        self.contains_key_with_buf(key, &mut EncodeBuffer::default()).await
    }

    /// Tries to generate an ID until it is successful. The ID is stored
    /// alongside with a value in a given tree using the given allocated buffer
    /// to serialize and dserialize key and value.
    pub async fn generate_id_with_buf<FK, FV, AK, AV, E>(
        &self,
        db: &sled::Db,
        buffer: &mut EncodeBuffer,
        mut make_id: FK,
        make_data: FV,
    ) -> Result<K, E>
    where
        FK: FnMut(Id) -> AK,
        FV: FnOnce(&K) -> AV,
        AK: Future<Output = Result<K, E>>,
        AV: Future<Output = Result<V, E>>,
        E: From<Error>,
    {
        loop {
            let gen_result = task::block_in_place(|| db.generate_id());
            let generated = gen_result.map_err(Error::from)?;
            let id = make_id(generated).await?;

            let contains = self.contains_key_with_buf(&id, buffer).await?;

            if !contains {
                let data = make_data(&id).await?;
                self.insert_with_buf(&id, &data, buffer).await?;
                break Ok(id);
            }

            task::yield_now().await;
        }
    }

    /// Tries to generate an ID until it is successful. The ID is stored
    /// alongside with a value in a given tree creating a one-time use buffer.
    pub async fn generate_id<FK, FV, AK, AV, E>(
        &self,
        db: &sled::Db,
        make_id: FK,
        make_data: FV,
    ) -> Result<K, E>
    where
        FK: FnMut(Id) -> AK,
        FV: FnOnce(&K) -> AV,
        AK: Future<Output = Result<K, E>>,
        AV: Future<Output = Result<V, E>>,
        E: From<Error>,
    {
        let mut buffer = &mut EncodeBuffer::default();
        self.generate_id_with_buf(db, &mut buffer, make_id, make_data).await
    }
}

impl<K, V> Clone for Tree<K, V>
where
    for<'de> K: serde::Serialize + serde::Deserialize<'de>,
    for<'de> V: serde::Serialize + serde::Deserialize<'de>,
{
    fn clone(&self) -> Self {
        Self { _marker: self._marker, storage: self.storage.clone() }
    }
}

impl<K, V> fmt::Debug for Tree<K, V>
where
    for<'de> K: serde::Serialize + serde::Deserialize<'de>,
    for<'de> V: serde::Serialize + serde::Deserialize<'de>,
{
    fn fmt(&self, fmtr: &mut fmt::Formatter) -> fmt::Result {
        fmtr.debug_struct("Tree").field("storage", &self.storage).finish()
    }
}
